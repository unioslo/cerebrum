# -*- coding: utf-8 -*-
#
# Copyright 2003-2023 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
"""
This module implements password history storage.

The py:class:`.PasswordHistory` class is used to keep track of previous
passwords for an account, mainly to prevent password reuse.

Passwords are hashed using pbkdf2_sha512 and stored in the password_history
table. Unlike account_authentication we retain historic values in this table.


Configuration
-------------
This module requires the design/mod_password_history.sql database module.

``cereconf.CLASS_ACCOUNT`` must have the py:class:`.PasswordHistoryMixin` in
order to store password hashes in ``password_history``.
Use py:class:`.ClearPasswordHistoryMixin` to only do maintenance/cleanup
without storing new password hashes in this table.


HISTORY
-------
This module was moved from Cerebrum.modules.PasswordHistory. For the old
structure of PasswordHistory, please see:

> commit 9a01d8b6ac93513a57ac8d6393de842939582f51
> Mon Jul 20 14:12:55 2015 +0200
"""
from __future__ import (
    absolute_import,
    division,
    print_function,
    unicode_literals,
)

import base64
import hashlib
import os

from Cerebrum.DatabaseAccessor import DatabaseAccessor
from Cerebrum.utils import date_compat

__version__ = "1.1"

pbkdf2_params = {
    'algo': 'sha512',
    'rounds': 10000,
    'salt_size': 32,
    'desired_key_len': 32,
}


def old_encode_for_history(name, password):
    """Hashes old password stored by md5hash."""
    m = hashlib.md5(name.encode('utf-8') + password.encode('utf-8'))
    return base64.b64encode(m.digest())[:22]


def encode_for_history(algo, rounds, salt, password, keylen):
    """ Hashes new passwords by pbkdf2 hash function

    :param int rounds: number of iterations
    :param str salt: random generated bytes
    :param str password: password user types in

    :return: (algorithm)$(rounds)$(salt)$(key generated)
    :rtype: string
    """
    hash_alg = "pbkdf2_" + algo
    password = password.encode('utf-8')
    hash_out = hashlib.pbkdf2_hmac(algo, password, salt, rounds, keylen)
    stored_salt = base64.b64encode(salt)
    key = base64.b64encode(hash_out)
    return "{}${}${}${}".format(hash_alg, rounds, stored_salt, key)


def check_password_history(password, old_passwords, name):
    # Only check the 5 newest passwords
    for old_password in old_passwords[-5:]:
        # check start to distinguish between old and new hash
        if old_password.startswith("pbkdf2_sha512"):
            # split hash, format alg$iterations$salt$key
            password_parts = old_password.split('$')
            iters = int(password_parts[1])
            salt = base64.b64decode(password_parts[2])
            # get params for the pbkdf2
            algo = pbkdf2_params['algo']
            keylen = pbkdf2_params['desired_key_len']
            encoded_password = encode_for_history(algo, iters, salt, password,
                                                  keylen)
            if encoded_password in old_passwords:
                return True
        else:
            encoded_password = old_encode_for_history(name, password)
            if encoded_password == old_password:
                return True
    return False


def check_passwords_history(variants, old_passwords, name):
    for variant in variants:
        if check_password_history(variant, old_passwords, name):
            return True
    return False


class ClearPasswordHistoryMixin(DatabaseAccessor):
    """ A mixin that will delete password history. """

    def delete(self):
        e_id = getattr(self, 'entity_id', None)
        if e_id is not None:
            PasswordHistory(self._db).del_history(e_id)
        super(ClearPasswordHistoryMixin, self).delete()


class PasswordHistoryMixin(ClearPasswordHistoryMixin):
    """ A mixin for use with entities that should have password history. """

    def set_password(self, plaintext):
        # We need our own copy of __plaintext_password, because the
        # Account-attribute is mangled ("private"). This also means we will
        # need to deal with clearing and deleting it ourselves.
        self.__plaintext_password = plaintext
        super(PasswordHistoryMixin, self).set_password(plaintext)

    def write_db(self):
        try:
            plain = self.__plaintext_password
            del self.__plaintext_password
        except AttributeError:
            plain = None
        ret = super(PasswordHistoryMixin, self).write_db()
        if plain is not None:
            ph = PasswordHistory(self._db)
            ph.add_history(self, plain)
        return ret

    def clear(self):
        try:
            del self.__plaintext_password
        except AttributeError:
            pass
        super(PasswordHistoryMixin, self).clear()

    def _bruteforce_check_password_history(self, password):
        """
        Check if this account have used a similar password before.

        Note that this check can be pretty expensive, as it needs to brute
        force different password combinations.

        :param str password: The plaintext password.

        :returns bool:
            - True if a similar password is found in password history
            - False/None if no matching password history record is found.
        """
        ph = PasswordHistory(self._db)
        name = getattr(self, 'account_name', None)
        entity_id = getattr(self, 'entity_id', None)

        if not name or not entity_id:
            return

        def what_range(ch):
            """
            Return a range of characters from character `ch'.

            This allows us to detect that the user changes password from
            '1secret' to '2secret'.
            """
            if not ch.isalpha():
                return range(ord(ch)-5, ord(ch)+6)
            if ch.isupper():
                return range(max(ord('A'), ord(ch)-5),
                             min(ord('Z')+1, ord(ch)+6))
            return range(max(ord('a'), ord(ch)-5),
                         min(ord('z')+1, ord(ch)+6))

        variants = []
        for m in (-1, 0):
            for r in what_range(password[m]):
                if m < 0:
                    tmp = password[:m]+chr(r)
                else:
                    tmp = chr(r)+password[m+1:]
                tmp = old_encode_for_history(name, tmp)
                variants.append(tmp)
        old_passwords = [r['hash'] for r in ph.get_history(entity_id)]
        return check_passwords_history(variants, old_passwords, name)

    def _check_password_history(self, password):
        """
        Check if this account have used the given password before.

        :param str password: The plaintext password.

        :returns bool:
            - True if the password is found in password history
            - False/None if no password history record is found.
        """
        ph = PasswordHistory(self._db)
        name = getattr(self, 'account_name', None)
        entity_id = getattr(self, 'entity_id', None)
        if not name or not entity_id:
            return

        old_passwords = [r['hash'] for r in ph.get_history(entity_id)]
        return check_password_history(password, old_passwords, name)


class PasswordHistory(DatabaseAccessor):
    """PasswordHistory contains an API for accessing password history."""

    def add_history(self, account, password, _csum=None, _when=None):
        """
        Add an entry to the password history.

        :param account: A populated account object
        :param password: Plaintext password to add
        :param _csum:
            Ignore plaintext password and store this checksum directly
        :param _when:
            Insert history record with this 'set_at' date or datetime value
        """
        entity_id = int(account.entity_id)

        if _csum is not None:
            csum = _csum
        else:
            algo = pbkdf2_params['algo']  # gets the name of the algorithm
            rounds = pbkdf2_params['rounds']
            salt = os.urandom(pbkdf2_params['salt_size'])
            keylen = pbkdf2_params['desired_key_len']
            csum = encode_for_history(algo, rounds, salt, password, keylen)

        if _when is not None:
            col_when = ", set_at"
            val_when = ", :when"
        else:
            col_when = val_when = ""
        when = date_compat.get_datetime_naive(_when)

        self.execute(
            """
            INSERT INTO [:table schema=cerebrum name=password_history]
              (entity_id, hash %s)
            VALUES
              (:e_id, :hash %s)""" % (col_when, val_when),
            {
                'e_id': entity_id,
                'hash': csum,
                'when': when,
            },
        )

    def del_history(self, entity_id):
        """
        Remove password history records for a given entity.

        :param int entity_id: The entity to remove password history records for
        """
        self.execute(
            """
            DELETE FROM [:table schema=cerebrum name=password_history]
            WHERE entity_id=:e_id
            """,
            {'e_id': entity_id},
        )

    def get_history(self, entity_id):
        """
        Fetch password history records for a given entity.

        :param int entity_id: The entity to remove password history records for
        """
        return self.query(
            """
            SELECT hash, set_at
            FROM [:table schema=cerebrum name=password_history]
            WHERE entity_id=:e_id
            ORDER BY set_at ASC
            """,
            {'e_id': entity_id},
        )

    def find_old_password_accounts(self, date):
        """
        Fetch active accounts that don't have recent password history records.

        This is typically used to find active accounts that haven't updated
        their password in a while.

        :param datetime.datetime date:
            Date cutoff.

            This method will return accounts *without* password history records
            after the given point in time.
        """
        # TODO: hva med systemkonti o.l. uten passord?  har alle karantene?

        # Fetch all account_id that:
        # - has spread
        # - has expire_date in the future/not set
        # - newest entry in password_history is older than <date>
        when = date_compat.get_datetime_naive(date, allow_none=False)
        return self.query(
            """
            SELECT account_id
            FROM [:table schema=cerebrum name=account_info] ai,
                 [:table schema=cerebrum name=password_history] ph
            WHERE (ai.expire_date IS NULL
                   OR ai.expire_date > [:now])
              AND ai.account_id=ph.entity_id
              AND EXISTS (
                SELECT 'foo'
                FROM [:table schema=cerebrum name=entity_spread] es
                WHERE ai.account_id=es.entity_id)
            GROUP BY ai.account_id
            HAVING MAX(set_at) < :date
            """,
            {'date': when},
        )

    def find_no_history_accounts(self):
        """
        Fetch active accounts that don't have any password history records.

        This is typically used to find active accounts that have never set a
        password.
        """
        return self.query(
            """
            SELECT account_id
            FROM [:table schema=cerebrum name=account_info] ai
            WHERE (ai.expire_date IS NULL
                   OR ai.expire_date > [:now])
              AND EXISTS (
                SELECT 'foo'
                FROM entity_spread es
                WHERE ai.account_id=es.entity_id)
              AND NOT EXISTS (
                SELECT 'foo'
                FROM entity_quarantine eq
                WHERE ai.account_id=eq.entity_id)
              AND NOT EXISTS (
                SELECT 'foo'
                FROM password_history ph
                WHERE ai.account_id=ph.entity_id)
            """)

    def get_most_recent_set_at(self, entity_id):
        """
        Get the most recent `set_at` timestamp for a given account, if any.

        This is typically used to find the most recent password change date for
        a given account.
        """
        result = self.query_1(
            """
              SELECT MAX(set_at)
              FROM [:table schema=cerebrum name=password_history]
              WHERE entity_id=:entity_id
            """,
            {'entity_id': int(entity_id)},
        )
        return date_compat.get_datetime_naive(result)

    def delete_set_before(self, when):
        """
        Remove all records before a given date.

        This is typically used to clean up password history records that are
        too old and no longer needed.

        :param datetime.datetime when:
            A date or datetime cutuff value.

            All history records set (set_at) before this point in time will be
            deleted.
        """
        return self.query(
            """
              DELETE FROM [:table schema=cerebrum name=password_history]
              WHERE set_at < :when
              RETURNING entity_id, set_at
            """,
            {'when': date_compat.get_datetime_naive(when, allow_none=False)},
            fetchall=True,
        )
