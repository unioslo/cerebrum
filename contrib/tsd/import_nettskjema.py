#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2013-2018 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
"""Job for importing JSON files generated from Nettskjema surveys.

See dokumentasjon/dokumentasjon/TSD/import-fra-nettskjema.rst -
https://www.usit.uio.no/om/tjenestegrupper/cerebrum/utvikling/dokumentasjon/TSD/import-fra-nettskjema.html
for how the import job is meant to work.

The data from Nettskjema is normally generated by researchers, asking for new
projects, registering themselves, adding changes to the project or asking about
new project resources. The person who has sent in the form has been
authenticated, e.g. by ID-porten, but no authorizations has been checked. All
requests from the JSON files must therefore be approved before it could be e.g.
synced to AD, or do anything harmful, like changing a person's name. Projects
and accounts must for instance start with a quarantine, to be approved by
superusers.

Tags that are important to us:

 - respondentNationalIdNumber: The FNR for the respondent.
   We must just trust that this number is authenticated through ID-porten,
   as long as we get the JSON files from TSD's closed environment.

 - questionId: An ID for the given answer that is manually set by the
   administrators of the survey. This is used to map answers into attributes in
   Cerebrum.

 - unfilteredTextAnswer: Used for questions that are just simple textfields.
   No filtering is done in Nettskjema, so we need to do all of that in here.
   Other question types have different tags that is used instead.

 - answerOptions: Used for questions where it is needed to select
   one alternative.
   The contents is the list of one element -- the ID of the answers.
"""
from __future__ import unicode_literals

import argparse
import contextlib
import datetime
import functools
import logging
import json
import os
import shutil
import time

import six

import cereconf

import Cerebrum.logutils
import Cerebrum.logutils.options
from Cerebrum import Errors
from Cerebrum.Utils import Factory
from Cerebrum.utils.date import now
from Cerebrum.utils.username import suggest_usernames
from Cerebrum.modules.no import fodselsnr
from Cerebrum.modules.tsd import Gateway

logger = logging.getLogger(__name__)

# TODO: Fixme - global values
db = None
co = None
gateway = None
systemaccount_id = None


def get_initial_account_id(db):
    """ get the entity_id of the INITIAL_ACCOUNTNAME. """
    ac = Factory.get('Account')(db)
    ac.find_by_name(cereconf.INITIAL_ACCOUNTNAME)
    return ac.entity_id


def get_archiver(directory, dryrun):
    """
    get a file archiver function.

    The archiver moves files to the given directory,
    but renames the moved file from BASENAME.EXT to:

        YYYY-MM-DD-BASENAME-COUNT.EXT

    where YYYY-MM-DD is the current date, and COUNT starts at 0 and goes
    upwards in case of naming collisions.

    :type directory: string
    :param directory: Directory to archive files in.

    :type dryrun: bool
    :param dryrun: Disables archiving if ``True``

    :returns:
        A function that moves a file to the given directory
    """

    def get_filename(orig, n):
        base, ext = os.path.splitext(orig)
        newname = '%s-%s-%s.%s' % (time.strftime('%Y%m%d'), base, n, ext)
        return os.path.join(directory, newname)

    def archive(filename):
        if directory is None:
            logger.debug('archiving disabled')
            return True

        count = 0
        new_file = get_filename(filename, count)
        while os.path.exists(new_file):
            count += 1
            new_file = get_filename(count)

        if dryrun:
            logger.info("Dryrun: Would archive %s to %s", filename, new_file)
            return True

        logger.info("Archiving %s to %s", filename, new_file)
        return shutil.move(filename, new_file)

    return archive


class InvalidFileError(Exception):
    """Exception for invalid files, e.g. it can't be parsed."""
    pass


@contextlib.contextmanager
def db_context(db, dryrun):
    """ simple commit/rollback handler. """
    try:
        yield db
        if dryrun:
            logger.info('rolling back changes (dryrun)')
            db.rollback()
        else:
            logger.info('commiting changes')
            db.commit()
    except Exception as e:
        logger.info('rolling back changes (unhandled %s)', type(e))
        db.rollback()
        raise


def process_files(files, dryrun, archive):
    """ Process a sequence of files.  """
    for afile in sorted(files):
        try:
            # TODO: Let db_context create a new db-transaction
            with db_context(db, dryrun):
                process_file(afile, dryrun)
                logger.info('Successfully processed %s', afile)
                archive(afile)
        except BadInputError as e:
            logger.warn("Bad input in file %s: %s", afile, e)
        except InvalidFileError as e:
            logger.warn("Problems with file %s: %s", afile, e)
        except Errors.CerebrumError:
            logger.error('Unable to import %s', afile, exc_info=True)


class BadInputError(Exception):
    """Exception for invalid input."""
    pass


class InputControl(object):
    """Class for validating and filtering the input.

    All control functions should return True if input is valid, or raise a
    BadInputError with a better explanation in case of errors. It could return
    just False, but no explanation would get logged about why the input was
    invalid.

    All the data given from the JSON forms must not be trusted, as it could be
    given by anyone with an FNR. The only data we could trust, is the FNR
    itself, as that is authenticated by ID-porten.
    """
    def is_projectid(self, name):
        """Check that a given projectname validates."""
        # TODO: Fix global db
        ou = Factory.get('OU')(db)
        try:
            return ou._validate_project_name(name)
        except Errors.CerebrumError as e:
            raise BadInputError(e)

    def is_valid_date(self, date):
        """Check that a date is parsable and valid."""
        try:
            self.filter_date(date)
        except Exception as e:
            raise BadInputError("Invalid date: " + str(e))
        return True

    def is_nonempty(self, txt):
        """Check that a string is not empty or only consists of whitespaces."""
        if not txt or not bool(txt.strip()):
            raise BadInputError('Empty string')
        return True

    def is_username(self, name):
        """Check that a given username is a valid username."""
        self.is_nonempty(name)
        # TODO: Fix global db
        ac = Factory.get('Account')(db)
        err = ac.illegal_name(name)
        if err:
            raise BadInputError('Illegal username: %s' % err)
        return True

    def is_phone(self, number):
        """Check if a phone number is valid."""
        self.is_nonempty(number)
        number = number.replace(' ', '')
        number = number.replace('-', '')
        if number.startswith('+'):
            number = number[1:]
        if number.isdigit():
            return True
        raise BadInputError('Invalid phone number: %s' % number)

    def is_email(self, adr):
        """Check if an e-mail address is valid."""
        self.is_nonempty(adr)
        # TODO: how much should we check here?
        if '@' not in adr:
            raise BadInputError('Invalid e-mail address: %s' % adr)
        return True

    def is_fnr(self, fnr):
        """Check if input is a valid, Norwegian fnr."""
        self.is_nonempty(fnr)
        # TODO: bogus fnr in test, add the check back when done testing:
        # fnr = fodselsnr.personnr_ok(fnr)
        return True

    def in_options(self, options):
        """Check if the answer is in a valid range of options.

        Actually returns a lambda that could be used by the validator.
        """
        def check(oinput):
            ret = oinput in options
            if not ret:
                raise BadInputError('Invalid option, should be one of: %s'
                                    % ', '.join(options))
            return ret
        return check

    def str(self, data):
        """Return the data as a string, stripped."""
        return six.text_type(data).strip()

    def filter_date(self, date):
        """Parse a date and return a datetime.date object."""
        # TODO: What date format should we use? Isn't ISO the best option?
        return datetime.datetime.strptime(date, '%d.%m.%Y').date()


check_input = InputControl()


# The map for changing the keys the new JSON schema has to the old ones,
# which the script uses throughout the code.
recode_keys = {
    '131473': 'p_id',
    '131472': 'p_name',
    '184420': 'p_shortname',
    '131480': 'project_start',
    '159706': 'project_end',
    '131478': 'rek_owner',
    '131479': 'inst_address',
    '131481': 'legal_notice',
    '131489': 'p_persons',
    '224781': 'vm_descr',
    '131474': 'pa_name',
    '131475': 'pa_phone',
    '131476': 'pa_email',
    '131477': 'pa_username',
    '181189': 'p_id',
    '181172': 'real_name',
    '181139': 'username',
    '226093': 'email',
    '226094': 'phone',
    '226486': 'smartphone',
    '181198': 'p_id',
    '181199': 'p_persons',
    '226096': 'pa_phone',
    '226095': 'pa_email'
}

# The dict to map answer options numerical codes to the corresponding string
# values
answer_options_map = {
    466097: 'linux_vm',
    466096: 'win_vm',
    466098: 'win_and_linux_vm',
    469051: 'smartphone_yes',
    469052: 'smartphone_no'
}

# Settings for input data
#
# This dict contains the settings for the input control and filter. The keys
# are the tag names that should be found in the file.
#
# Tag found in submission, mapped to requirement func, filter func and name of
# variable.
input_values = {
    # Project ID
    'p_id': (check_input.is_projectid, check_input.str),
    # Project full name
    'p_name': (check_input.is_nonempty, check_input.str),
    # Project short name
    'p_shortname': (check_input.is_nonempty, check_input.str),
    # Project start date
    'project_start': (check_input.is_valid_date, check_input.filter_date),
    # Project end date
    'project_end': (check_input.is_valid_date, check_input.filter_date),
    # Project owner's FNR
    'rek_owner': (check_input.is_fnr, check_input.str),
    # Project's institution's address
    'inst_address': (check_input.is_nonempty, check_input.str),
    # Project's REK approval number
    'legal_notice': (check_input.is_nonempty, check_input.str),
    # Project members, identified by FNR
    'p_persons': (lambda x: True, check_input.str),
    # PA's full name
    'pa_name': (check_input.is_nonempty, check_input.str),
    # PA's phone number
    'pa_phone': (check_input.is_phone, check_input.str),
    # PA's e-mail address
    'pa_email': (check_input.is_email, check_input.str),
    # PA's chosen username
    'pa_username': (check_input.is_username, check_input.str),
    # The respondent's chosen username. Not necessarily mandatory.
    'username': (lambda x: True, check_input.str),
    # The respondent's full name
    'real_name': (check_input.is_nonempty, check_input.str),
    # The respondent's e-mail address
    'email': (check_input.is_email, check_input.str),
    # The respondent's phone number
    'phone': (check_input.is_phone, check_input.str),
    # What resources that should be used in a given project:
    'vm_descr': (check_input.in_options(cereconf.TSD_VM_TYPES),
                 check_input.str),
    # If the person should use OTP through smartphone or yubikey:
    'smartphone': (lambda x: True, check_input.str),
}


# A list of all the required input values for each defined survey type. This is
# used to identify the survey type.
survey_types = {
    'new_project': ('p_id', 'p_name', 'p_shortname', 'project_start',
                    'project_end', 'rek_owner', 'inst_address',
                    'legal_notice', 'p_persons', 'pa_name', 'pa_phone',
                    'pa_email', 'pa_username', 'vm_descr'),
    'project_access': ('p_id', 'real_name', 'username', 'email', 'phone',
                       'smartphone',),
    'approve_persons': ('p_id', 'p_persons'),
}


def _json2answersdict(json_data):
    """Parse the JSON and return a dict with all the answers.

    No input control or filtering is performed in this function, but only input
    values that are defined in L{input_values} by their external-ID gets
    returned.

    @type json_data: dict
    @param json_data: The given submission, as an JSON dict.

    @rtype: dict
    @return: A mapping of the answers. Keys are the id of the answer,
        and the values are the answers, most often as strings.
    """
    ret = dict()
    answers = json_data['answersAsMap']

    if answers is None:
        raise InvalidFileError('Missing entry "answersAsMap"')
    for id, ans in answers.items():
        if id not in recode_keys:
            # Ignore undefined questions
            continue
        # Answers could either be put in a unfilteredTextAnswer element,
        # which is then a simple string or integer,
        # or it could be an answerOptions array.
        # Note that both elements are always present, though both may be empty.
        answer = None
        if ans['answerOptions']:
            # Cumbersome addressing. 'answerOptions' is a list, containing
            # only one dict element
            answer_option = ans['answerOptions'][0]['answerOptionId']
            if answer_option not in answer_options_map:
                logger.warn("For question %s, got un unknown answerOption: %s",
                            recode_keys[id], answer_option)
                continue
            else:
                answer = answer_options_map[answer_option]
        else:
            answer = ans['unfilteredTextAnswer']
        ret[recode_keys[id]] = answer
    return ret


def json2answers(json_data):
    """Fetch and check answers from JSON, and guess the submission type.

    The answers are processed through the input control and filter settings in
    L{input_values}.

    Since the JSON does not have an identifier of what survey it is about, we
    need to guess it by finding the L{survey_type} that has all its questions
    answered in the JSON. The IDs are used for this.

    Note that you *could* get a file that matches more than one survey type,
    which is an error. You then either have to fix the config of
    L{input_values} and L{survey_types}, or you need to change the defined IDs
    in the form at Nettskjema.

    @type json_data: dict
    @param json_data:
        The parsed content of a file from Nettskjema.

    @rtype: (string, dict)
    @return: The first element contains the id of the submission type, defined
        in L{survey_types}, followed by a dict with the answers. The keys are
        from L{input_values} and the values are the filtered answers.
    """
    answers = _json2answersdict(json_data)
    # Find the correct survey type:
    stypes = []
    for stype, requireds in survey_types.iteritems():
        if all(req in answers for req in requireds):
            stypes.append(stype)
    if not stypes:
        raise InvalidFileError('No matching survey type for answers: %s' %
                               answers.keys())
    if len(stypes) > 1:
        # Find the type with the most correct answers:
        stypes = sorted(stypes, reverse=True, key=lambda x:
                        len(survey_types[x]))
        # Check if it's a tie
        if len(survey_types[stypes[0]]) == len(survey_types[stypes[1]]):
            raise InvalidFileError(
                'Could not uniquely identify submission '
                'type: %s, keys: %s' % (stypes[:2], answers.keys()))
    stype = stypes[0]
    # Do the input control and filtering:
    ret = dict()
    for extid in survey_types[stype]:
        control, filter = input_values[extid]
        answer = answers[extid]
        try:
            control_ans = control(answer)
        except BadInputError as e:
            raise BadInputError('Answer "%s" invalid: %s. Answer: %s' % (
                extid,
                e,
                answer))
        if not control_ans:
            raise BadInputError('Answer "%s" invalid: %s' % (extid, answer))
        ret[extid] = filter(answer)
    return stype, ret


def process_file(afile, dryrun):
    logger.info("Processing file: %s", afile)

    with open(afile, 'r') as json_file:
        json_data = json.load(json_file)

    stype, answers = json2answers(json_data)
    try:
        fnr = json_data['respondentNationalIdNumber']
    except AttributeError:
        raise Exception("Bad file, missing mandatory FNR tag from ID-porten")
    logger.debug('Submission, type "%s", respondent: "%s", answers: %d',
                 stype,
                 fnr,
                 len(answers))
    for k in sorted(answers):
        logger.debug("  %s: %s", k, answers[k])

    # Do the Cerebrum processing:
    p = Processing(fnr=fnr)
    ret = getattr(p, stype)(answers)
    logger.debug("Submission processed: %s" % ret)
    return ret


class Processing(object):
    """Handles the processing of the parsed and validated JSON data."""

    def __init__(self, fnr):
        """Set up the processing.

        @type fnr: string
        @param fnr: The fødselsnummer for the person that sent in the survey
                     and requested some changes in TSD.
        """
        self.fnr = fnr
        self.start_now = datetime.date.today()
        self.start_past = (datetime.date.today()
                           - datetime.timedelta(days=1000))

    def _get_person(self, fnr=None, create_nonexisting=True):
        """Return the person with the given fnr.

        If the person does not exist, it gets created. Names and all other data
        but the fnr needs to be added to the person.

        @type fnr: string
        @param fnr: A (valid) fødselsnummer for the person to find.

        @type create_nonexisting: bool
        @param create_nonexisting: If the person is not found in Cerebrum,
            should we create it?
            If False, you will instead get a NotFoundError.

        @raise NotFoundError: If the person is not found and
            L{create_nonexisting} is False, so that we can't create the person.
        """
        if not fnr:
            fnr = self.fnr
        # TODO: Fix global db
        pe = Factory.get('Person')(db)
        try:
            pe.find_by_external_id(id_type=co.externalid_fodselsnr,
                                   external_id=fnr)
        except Errors.NotFoundError:
            if not create_nonexisting:
                raise
            logger.info("Creating new person, with fnr: %s", fnr)
            pe.clear()
            pe.populate(birth_date=None, gender=co.gender_unknown)
            pe.write_db()
            pe.affect_external_id(co.system_nettskjema,
                                  co.externalid_fodselsnr)
            pe.populate_external_id(source_system=co.system_nettskjema,
                                    id_type=co.externalid_fodselsnr,
                                    external_id=fnr)
            pe.write_db()
        return pe

    def _update_person(self, pe, input):
        """Update the data about a given person.

        Update names, contact info and other available data. No project related
        data is added or modified.
        """
        # Full name
        for key in ('pa_name', 'real_name'):
            if key in input:
                logger.debug("Updating name: %s", input[key])
                pe.affect_names(co.system_nettskjema, co.name_full)
                pe.populate_name(co.name_full, input[key])
                pe.write_db()

        # Phone
        for key in ('pa_phone', 'phone'):
            if key in input:
                logger.debug("Updating phone: %s", input[key])
                pe.populate_contact_info(source_system=co.system_nettskjema,
                                         type=co.contact_phone,
                                         value=input[key])
                pe.write_db()
        # E-mail
        for key in ('pa_email', 'email'):
            if key in input:
                logger.debug("Updating mail: %s", input[key])
                pe.populate_contact_info(source_system=co.system_nettskjema,
                                         type=co.contact_email,
                                         value=input[key])
                pe.write_db()
        # Smartphone or yubikey
        for key in ('smartphone',):
            if key in input:
                logger.debug("Updating otp-device: %s", input[key])
                pe.populate_trait(co.trait_otp_device, date=now(),
                                  strval=six.text_type(input[key]))
                pe.write_db()

    def _create_ou(self, input):
        """Create the project OU based on given input."""
        pname = input['p_id']
        # TODO: Fix global db
        ou = Factory.get('OU')(db)
        pid = ou.create_project(pname)
        logger.debug("New project %s named: %s", pid, pname)
        logger.debug("Project start=%r end=%r", input['project_start'],
                     input['project_end'])

        # The gateway should not be informed about new projects before they're
        # approved, so if we should create the project in the GW, we must also
        # execute: gateway.freeze_project(pid)

        longname = input['p_name']
        logger.debug("Storing project name: %s", longname)
        ou.add_name_with_language(name_variant=co.ou_name_long,
                                  name_language=co.language_en, name=longname)
        shortname = input['p_shortname']
        logger.debug("Storing project short name: %s", shortname)
        ou.add_name_with_language(name_variant=co.ou_name_long,
                                  name_language=co.language_en, name=shortname)
        ou.write_db()

        # Always start projects quarantined, needs to be approved first!
        logger.debug("Project %s starting in quarantine 'not_approved'", pid)
        ou.add_entity_quarantine(qtype=co.quarantine_not_approved,
                                 creator=systemaccount_id,
                                 description='Project not approved yet',
                                 start=self.start_now)
        ou.write_db()

        # Storing the start and end date:
        endtime = input['project_end']
        if endtime < self.start_now:
            raise BadInputError("End date of project has passed: %s" % endtime)
        ou.add_entity_quarantine(
            qtype=co.quarantine_project_end,
            creator=systemaccount_id,
            description='Initial requested lifetime for project',
            start=endtime)
        ou.write_db()
        starttime = input['project_start']
        # We always set the start time quarantine, even if the start time has
        # passed. This is to let the administrators see the start time in bofh.
        ou.add_entity_quarantine(
            qtype=co.quarantine_project_start,
            creator=systemaccount_id,
            description='Initial requested starttime for project',
            start=self.start_past,
            end=starttime)
        ou.write_db()

        ou.populate_trait(co.trait_project_institution, target_id=ou.entity_id,
                          strval=input['inst_address'])
        ou.populate_trait(co.trait_project_rek, target_id=ou.entity_id,
                          strval=input['legal_notice'])
        # TODO: Should we have a mapping of vm_descr?
        ou.populate_trait(co.trait_project_vm_type, target_id=ou.entity_id,
                          strval=input['vm_descr'])
        ou.write_db()
        logger.debug("New project created successfully: %s", pid)
        # The project will not be properly set up before it gets approved. The
        # gateway will for instance not hear about it before it's approved.
        return ou

    def _generate_username(self, pid, pe, ac):
        """Helper method for generating a project username for a given person.
        """
        fname = pe.get_name(co.system_cached, co.name_first)
        lname = pe.get_name(co.system_cached, co.name_last)
        # create a validation callable (function)
        vfunc = functools.partial(ac.validate_new_uname,
                                  co.account_namespace,
                                  owner_id=pe.entity_id)
        for name in suggest_usernames(
                fname,
                lname,
                maxlen=cereconf.USERNAME_MAX_LENGTH,
                prefix='%s-' % pid,
                validate_func=vfunc
        ):
            return name
        raise Exception("No available username for %s in %s" % (pe.entity_id,
                        pid))

    def _get_username(self, pe, ou, requestedname=None):
        """Find a proper project username for the person.

        The username is generated on the following basis:

        - If the person does not have any other TSD-account:
            - If the requested name is valid and available: return that one.
            - If not, generate a username.
        - If the person has another TSD-account: Use the format of one of the
          accounts for the new project. This will fail if the username is taken
          by someone else.

        @type pe: Person object
        @param pe: The instantiated person that should get an account.

        @type ou: OU object
        @param ou: The instantiated project OU where the account should belong.

        @type requestedname: str
        @param requestedname:
            A username that the person has asked for having. This will be
            ignored if the person already has a TSD-account.

        @rtype: str
        @return: The chosen, available username.
        """
        pid = ou.get_project_id()
        # TODO: Fix global db
        ac = Factory.get('Account')(db)
        other_acs = ac.search(owner_id=pe.entity_id)
        if not other_acs:
            logger.debug("No other accounts for person %s", pe.entity_id)
            if requestedname:
                rname_lower = requestedname.lower()
                rname = '%s-%s' % (pid, rname_lower)
                if (
                        not ac.illegal_name(rname) and
                        not ac.search(name='p*-{}'.format(rname_lower))
                ):
                    return rname
            return self._generate_username(pid, pe, ac)
        for row in other_acs:
            logger.debug(
                "Person %s has other accounts, ignoring requestedname",
                pe.entity_id)
            # Strip out the project prefix and give it the new pid
            uname = ac.get_username_without_project(row['name'])
            new_name = '%s-%s' % (pid, uname)
            # TODO: If a person should be able to have more than one account in
            # a project, we should also check if ac.owner_id == pe.entity_id
            # and skip those without an exception.
            if ac.search(name=new_name):
                raise Exception(
                    "Failed giving %s username: %s, already taken" % (
                        pe.entity_id,
                        new_name))
            return new_name

    def _create_account(self, pe, ou, requestedname):
        """Create an account for a given project.

        The person must already be affiliated with the project for the account
        to be created. If the person only has a pending affiliation,
        the account gets quarantined.

        If the project has been approved and is set up properly, the account
        could become a posix user. Otherwise, the account is only a regular
        account, e.g. without a DFG, as no such group is created before the
        project approval.
        """
        ou_is_approved = ou.is_approved()
        pid = ou.get_project_id()
        # TODO: Fix global db
        ac = Factory.get('Account')(db)
        # Not set usernames or invalid usernames gets ignored
        username = self._get_username(pe, ou, requestedname)
        logger.info("Creating project user for person %s: %s",
                    pe.entity_id,
                    username)
        # Check if the project has been accepted, i.e. is active:
        if ou_is_approved:
            # The project is in quarantine, probably due to not accepted.
            # Should not start handing out posix data yet, then.
            ac.populate(name=username,
                        owner_type=pe.entity_type,
                        owner_id=pe.entity_id,
                        np_type=None,
                        creator_id=systemaccount_id,
                        expire_date=None)
        else:
            # Project is active, creating posix user instead:
            ac = Factory.get('PosixUser')(db)
            ac.populate(posix_uid=ac.get_free_uid(),
                        gid_id=None,
                        gecos=None,
                        shell=co.posix_shell_bash,
                        name=username,
                        owner_type=pe.entity_type,
                        owner_id=pe.entity_id,
                        np_type=None,
                        creator_id=systemaccount_id,
                        expire_date=None)
        ac.write_db()

        # Check if the person is already accepted and affiliated with the
        # project, or only pending:
        if pe.list_affiliations(pe.entity_id, ou_id=ou.entity_id,
                                affiliation=co.affiliation_project):
            # Approved account:
            logger.debug("Account %s approved for project: %s",
                         ac.account_name,
                         pid)
            ac.set_account_type(ou.entity_id, co.affiliation_project)
            realname = pe.get_name(co.system_cached, co.name_full)
            if ou_is_approved:
                ac.add_entity_quarantine(
                    qtype=co.quarantine_not_approved,
                    creator=systemaccount_id,
                    description='Project not yet approved',
                    start=self.start_now)
            else:
                try:
                    gateway.create_user(uid=ac.posix_uid,
                                        pid=pid,
                                        username=username,
                                        realname=realname)
                except Gateway.GatewayException:
                    logger.info("User will arrive in GW at next fullsync")
        elif pe.list_affiliations(pe.entity_id, ou_id=ou.entity_id,
                                  affiliation=co.affiliation_pending):
            # Pending account:
            logger.debug("Account %s pending for project: %s", ac.account_name,
                         pid)
            ac.set_account_type(ou.entity_id, co.affiliation_pending)
            ac.add_entity_quarantine(qtype=co.quarantine_not_approved,
                                     creator=systemaccount_id,
                                     description='User not yet approved',
                                     start=self.start_now)
        else:
            # TODO: Should the JSON file now be deleted automatically?
            raise BadInputError("Person %s not affiliated to project %s",
                                pe.entity_id, ou.entity_id)
        ac.write_db()

        # TODO: quarantine for start and end dates, or is the project's
        # quarantine enough for that?
        return ac

    def _get_project_account(self, pe, ou):
        """Find a person's project accounts, if any.

        Note that a person *could* have more than one account per project, even
        if that would not make much sense.
        """
        # TODO: Fix global db
        ac = Factory.get('Account')(db)
        return ac.list_accounts_by_type(ou_id=ou.entity_id,
                                        person_id=pe.entity_id)

    def new_project(self, input):
        """Create a given project.

        TODO: A lot of this code should be moved into e.g. TSD's OU mixin, or
        somewhere else to be usable both by various scripts and bofhd.

        @type input: dict
        @param input: The survey answers about the requested project.
        """
        pname = input['p_id']
        logger.info('New project: %s', pname)
        ou = self._create_ou(input)

        # Update the requestee for the project:
        pe = self._get_person()
        self._update_person(pe, input)

        # Give the respondent an affiliation to the project.
        # If the respondent sets himself as the Project Owner (responsible), it
        # gets status as the owner. Otherwise we give him PA status:
        # TBD: do we need to differentiate between owner and PA?
        status = co.affiliation_status_project_admin
        if self.fnr == input['rek_owner']:
            status = co.affiliation_status_project_owner
        pe.populate_affiliation(source_system=co.system_nettskjema,
                                ou_id=ou.entity_id, status=status,
                                affiliation=co.affiliation_project)
        pe.write_db()

        # Check the responsible and give access to the project by an
        # affiliation:
        if self.fnr != input['rek_owner']:
            # TODO: Should we create a person with this ID or not?
            try:
                pe2 = self._get_person(input['rek_owner'],
                                       create_nonexisting=False)
                pe2.populate_affiliation(
                    source_system=co.system_nettskjema,
                    ou_id=ou.entity_id,
                    affiliation=co.affiliation_project,
                    status=co.affiliation_status_project_owner)
                # Note that no name or anything else is now set, so we wait
                # with the account.
                pe2.write_db()
            except Errors.NotFoundError:
                logger.warn("Project owner not found: %s", input['rek_owner'])

        # Give the PA an account:
        self._create_account(pe, ou, input['pa_username'])

        # Fill the pre approve list with external ids:
        pre_approve_list = set()
        for fnr in set(input['p_persons'].split()):
            for fnr1 in set(fnr.split(',')):
                try:
                    fnr1 = fodselsnr.personnr_ok(fnr1)
                except fodselsnr.InvalidFnrError:
                    logger.debug("Ignoring invalid fnr: %s", fnr1)
                    continue
                except ValueError:
                    logger.debug("Ignoring invalid fnr: %s", fnr1)
                    continue
                pre_approve_list.add(fnr1)
        if pre_approve_list:
            logger.debug("Pre approvals: %s", ', '.join(pre_approve_list))
            ou.add_pre_approved_persons(pre_approve_list)
            ou.write_db()

    def project_access(self, input):
        """Setup a request for the respondent to join a project.

        This is a survey that should be filled out for when a person wants to
        join a certain project as a project member. We create a person object
        for the respondent, if it doesn't already exist. Next we create a
        project account that is quarantined, and have to get accepted by PA or
        administrators before it could start working on the project.

        Note that the given information could be filled out by anyone. The
        project account must therefore be approved by PA or administrators
        before the person could be used in Cerebrum. The only data we could
        trust is the FNR, which we must trust is authentic and from ID-porten,
        so we know who filled out the form.

        @type input: dict
        @param input: The survey answers.
        """
        logger.debug('Asking for project access')
        # Update the requestee for the project:
        pe = self._get_person()
        self._update_person(pe, input)

        # Find the project:
        pid = input['p_id']

        # TODO: Fix global db
        ou = Factory.get('OU')(db)
        ou.find_by_tsd_projectid(pid)

        # Check that the person is not already in the project:
        for row in pe.list_affiliations(person_id=pe.entity_id,
                                        affiliation=co.affiliation_project,
                                        ou_id=ou.entity_id):
            logger.info("person_id=%d already affiliated with project %s",
                        pe.entity_id, pid)
            # nothing more to do for this person
            return

        # Check if the person is pre approved for the project:
        approved = False
        if self.fnr in ou.get_pre_approved_persons():
            logger.debug("Person %s was pre approved", self.fnr)
            approved = True

        if approved:
            logger.info("Adding member aff to project %s for %s", pid,
                        pe.entity_id)
            pe.populate_affiliation(
                source_system=co.system_nettskjema,
                ou_id=int(ou.entity_id),
                affiliation=int(co.affiliation_project),
                status=co.affiliation_status_project_member)
            pe.write_db()
            # TODO: remove fnr from project's list of pre approved persons.
        else:
            logger.info("Adding pending aff to project %s for %s", pid,
                        pe.entity_id)
            pe.populate_affiliation(
                source_system=co.system_nettskjema,
                ou_id=ou.entity_id, affiliation=co.affiliation_pending,
                status=co.affiliation_status_pending_project_member)
            pe.write_db()

        # Check if the person already has an account:
        accounts = self._get_project_account(pe, ou)
        if accounts:
            # TODO: This *may* be the wrong behaviour - and we should just
            #       write any changes and return
            logger.info("person_id=%d already has project accounts (%s)",
                        pe.entity_id,
                        ', '.join(six.text_type(a['account_id'])
                                  for a in accounts))
            # no need to create an account
            return

        self._create_account(pe, ou, input['username'])

    def approve_persons(self, input):
        """Let project owner and PAs approve more persons to their project.

        Sending this through Nettskjema is needed as we have no web GUI inside
        TSD in the beginning, and project admins need a way to approve people
        for their projects.
        """
        # Find the project:
        pid = input['p_id']
        # TODO: Fix global db
        ou = Factory.get('OU')(db)
        ou.find_by_tsd_projectid(pid)
        logger.info('Approve persons for project: %s', pid)

        # Find the requestor
        pe = self._get_person()

        # The requestor must be owner or PA:
        if not list(pe.list_affiliations(
                person_id=pe.entity_id,
                affiliation=co.affiliation_project,
                status=(co.affiliation_status_project_owner,
                        co.affiliation_status_project_admin),
                ou_id=ou.entity_id)):
            # TODO: Delete the JSON file?
            raise BadInputError("Person %s is not PA of project %s" % (
                pe.entity_id,
                pid))

        # Update contact info for PA:
        self._update_person(pe, input)

        # TODO: Fix global db
        # Try to find and add the given person to the project
        pe2 = Factory.get('Person')(db)
        ac = Factory.get('Account')(db)
        pre_approvals = set()
        for fnr in set(input['p_persons'].split()):
            for fnr1 in set(fnr.split(',')):
                try:
                    fnr1 = fodselsnr.personnr_ok(fnr1)
                except fodselsnr.InvalidFnrError:
                    logger.debug("Ignoring invalid fnr: %s", fnr1)
                    continue
                # Find the person:
                try:
                    pe2 = self._get_person(fnr1, create_nonexisting=False)
                except Errors.NotFoundError:
                    logger.info(
                        "Person %s not found, added to pre approve list",
                        fnr1)
                    pre_approvals.add(fnr1)
                    continue
                # Affiliate person to project:
                if not pe2.list_affiliations(
                        person_id=pe2.entity_id,
                        ou_id=ou.entity_id,
                        affiliation=co.affiliation_project):
                    logger.info("Approve person %s for project: %s", fnr1, pid)
                    pe2.populate_affiliation(
                        source_system=co.system_nettskjema,
                        ou_id=ou.entity_id,
                        affiliation=co.affiliation_project,
                        status=co.affiliation_status_project_member)
                # Remove pending aff, if set. Note that this also removes any
                # other pending statuses,
                # if we should create more of those in the future.
                pe2.delete_affiliation(
                    ou_id=ou.entity_id,
                    affiliation=co.affiliation_pending,
                    source=co.system_nettskjema)
                pe2.write_db()

                # Find the member's project account, if it exist:
                accounts = self._get_project_account(pe2, ou)
                if not accounts:
                    logger.info(
                        "No project account for %s, added to approve list",
                        fnr1)
                    pre_approvals.add(fnr1)
                    continue
                ac.clear()
                ac.find(accounts[0]['account_id'])
                logger.info("Approving person %s PM to %s: %s ", fnr1,
                            ac.account_name, pid)

                # Update the account types:
                ac.set_account_type(ou.entity_id, co.affiliation_project)
                # TODO: check if this works if the type is already set:
                ac.del_account_type(ou.entity_id, co.affiliation_pending)
                ac.del_account_type(ou.entity_id, co.affiliation_pending)
                # Remove quarantine:
                ac.delete_entity_quarantine(co.quarantine_not_approved)
                ac.write_db()

                # Promote posix:
                if ou.is_approved():
                    pu = Factory.get('PosixUser')(db)
                    try:
                        pu.find(ac.entity_id)
                    except Errors.NotFoundError:
                        uid = pu.get_free_uid()
                        pu.populate(uid,
                                    None,
                                    None,
                                    co.posix_shell_bash,
                                    parent=ac,
                                    creator_id=systemaccount_id)
                        logger.debug("Promote POSIX, UID: %s",
                                     ac.entity_id,
                                     uid)
                        pu.write_db()

        # Store those not processed for later approval:
        if pre_approvals:
            logger.debug("Remaining non-existing persons: %d",
                         len(pre_approvals))
            ou.add_pre_approved_persons(pre_approvals)
            ou.write_db()


def collect_files(items):
    """
    Find all existing files in a sequence of pathnames.

    :param items: an iterable of files and directories
    """
    for item in items:
        if os.path.isdir(item):
            for filename in os.listdir(item):
                yield os.path.join(item, filename)
        elif os.path.exists(item):
            yield item
        else:
            logger.warn("Ignoring unknown path: %s", item)


def dir_type(value):
    """ Assert value is a directory. """
    if not os.path.isdir(value):
        raise ValueError('not a directory: ' + repr(value))
    return value


def main(inargs=None):
    # TODO: Get rid of globals
    global db, co, gateway, systemaccount_id

    parser = argparse.ArgumentParser(
        description='Import json data from nettskjema forms',
    )
    parser.add_argument(
        '--archive',
        type=dir_type,
        help='move processed json files to %(metavar)s',
        metavar='DIR',
    )

    # TODO: make dryrun the default (must first add --commit to scheduled_jobs)
    default_commit = True
    default_msg = " (this is the default)"
    commit_mutex = parser.add_mutually_exclusive_group()
    commit_mutex.add_argument(
        '--commit',
        dest='commit',
        action='store_true',
        help="commit changes" + (default_msg if default_commit else ""),
    )
    commit_mutex.add_argument(
        '-d', '--dryrun',
        dest='commit',
        action='store_false',
        help=("dryrun - do not commit changes or move files"
              + ("" if default_commit else default_msg)),
    )
    commit_mutex.set_defaults(commit=default_commit)

    parser.add_argument(
        '--no-gateway',
        dest='gateway_dryrun',
        action='store_true',
        help=("do not communicate changes to gateway"
              " (default: follows --commit/--dryrun)")
    )
    parser.add_argument(
        'items',
        nargs='+',
        help="json file or directory of json files to import",
    )
    Cerebrum.logutils.options.install_subparser(parser)

    args = parser.parse_args(inargs)
    Cerebrum.logutils.autoconf('cronjob', args)

    # Configure global values
    db = Factory.get('Database')(client_encoding='utf-8')
    co = Factory.get('Constants')(db)
    gateway = Gateway.GatewayClient(logger.getChild('gateway'))
    systemaccount_id = get_initial_account_id(db)
    db.cl_init(change_by=systemaccount_id)

    logger.info("Start %s", parser.prog)

    dryrun = not args.commit
    gateway.dryrun = args.gateway_dryrun or dryrun
    logger.debug('dryrun: %r, gateway.dryrun: %r', dryrun, gateway.dryrun)

    do_archive = get_archiver(directory=args.archive, dryrun=dryrun)
    logger.debug('archive: directory=%r, dryrun=%r', args.archive, dryrun)

    files = set(collect_files(args.items))
    logger.info('found %d files to import', len(files))
    if not files:
        parser.error('no files to import in: ' + repr(args.items))

    process_files(files, dryrun, do_archive)

    logger.info("Done %s", parser.prog)


if __name__ == '__main__':
    main()
