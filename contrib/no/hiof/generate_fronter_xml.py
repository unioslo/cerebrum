#!/usr/bin/env python
# -*- encoding: utf-8 -*-
#
# Copyright 2009-2024 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""This file contains the code to generate an XML file for import into
Fronter, HiØf's LMS.

It works in conjunction with populate_fronter_groups.py and is meant to
complement it -- p_f_g generates the necessary groups whereas g_f_x generates
an XML file from these groups.

All groups making the basis for XML output are tagged with a special trait,
and they have a highly structured name.

The script works like this:

  - Grab all group_ids generated by populate_fronter_groups (they are tagged
    by a special trait) -- collect_cf_groups.
  - Parse undenh/undakt files are build a dict to remap multisemester
    entities -- build_multisemester_mapping.
  - Build a tree, in memory, representing the fronter tree
    (build_cf_tree). The tree is built by successively inserting a node for a
    cerebrum group (CfMemberGroup) into the tree
    (create_associated_structures). Permissions are registered as well.
  - Once the tree is complete, it's output to an XML file. We output (in
    order): all the people (output_people), all the groups (structure- and
    member -- output_member_groups), all the memberships representing people
    being in a group, and finally all the permissions (these are memberships
    as well, but between groups only)
  - Profit!

"""

from __future__ import unicode_literals

import argparse
import datetime
import logging
import re
from collections import deque

import six

import cereconf

import Cerebrum.logutils
import Cerebrum.logutils.options
from Cerebrum.Utils import Factory
from Cerebrum.utils.atomicfile import SimilarSizeWriter
from Cerebrum.extlib import xmlprinter
from Cerebrum.modules.xmlutils.fsxml2object import EduDataGetter
from Cerebrum.modules.no.hiof.fronter_lib import lower
from Cerebrum.modules.no.hiof.fronter_lib import count_back_semesters
from Cerebrum.modules.no.hiof.fronter_lib import timeslot_is_valid
from Cerebrum.modules.Email import EmailAddress
from Cerebrum.modules.Email import EmailTarget
from Cerebrum.modules.Email import EmailServer
from Cerebrum import Errors


STATUS_ADD = "1"
STATUS_UPDATE = "2"
STATUS_DELETE = "3"
logger = logging.getLogger(__name__)
uname_suffix = ''


@six.python_2_unicode_compatible
class CfPermission(object):
    """Permission handling.

    Objects of this class capture the fact that a group has a certain
    permission granted on another group.
    """

    ROLE_READ = '01'
    ROLE_WRITE = '02'
    ROLE_DELETE = '06'
    ROLE_CHANGE = '07'

    access2symbol = {
        ROLE_READ: "READ",
        ROLE_WRITE: "WRITE",
        ROLE_DELETE: "DELETE",
        ROLE_CHANGE: "CHANGE",
    }

    def __init__(self, access_type, recursive, holder, target):
        # Does the permission apply recursively?
        self._recursive = recursive
        # read/write/delete/change
        self._access = access_type
        # the group that has the permissions on target
        self._holder = holder
        # the 'victim' of the permission assignment
        self._target = target
        assert self._access in self.access2symbol

    def access_type(self):
        return self._access

    def is_recursive(self):
        return self._recursive

    def target(self):
        return self._target

    def holder(self):
        return self._holder

    def __str__(self):
        return "cf_perm %s (%s) for %s on %s" % (
            self.access2symbol[self.access_type()],
            self.is_recursive() and "recursive" or "non-recursive",
            self.holder(),
            self.target())


class CfTree(object):
    """
    Representation of the data structure to be pushed to the XML file.
    """

    def __init__(self, db):
        self._root = None
        self._person_group_holder = None
        self._cf_id2node = dict()
        self._db = db

        self._build_static_nodes()

    def _build_static_nodes(self):
        """Build the static part of OA/hiof's CF tree"""

        self._root = CfStructureGroup("Oslofjordalliansen", "root", None)
        self.register_structure_group(self._root)

        hiof = CfStructureGroup("HiØ", "STRUCTURE:hiof.no", self._root)
        self.register_structure_group(hiof)

        tmp = CfStructureGroup("Automatisk",
                               "STRUCTURE:hiof.no:automatisk", hiof)
        self.register_structure_group(tmp)
        tmp = CfStructureGroup("Manuell",
                               "STRUCTURE:hiof.no:manuell", hiof)
        self.register_structure_group(tmp)

        # It knows about root, but not the other way
        # around. _person_group_holder is somewhat special -- it's a fake
        # node: it does not have any members, really, it is only a container
        # for all groups with members in them.
        self._person_group_holder = CfStructureGroup(
            "Samlenode for persongruppene",
            "STRUCTURE:hiof.no:persongruppene",
            None)
        self._person_group_holder._parent = self._root

    def get_cf_group(self, cf_id, default=None):
        return self._cf_id2node.get(cf_id, default)

    def register_member_group(self, cfmg):
        assert isinstance(cfmg, CfMemberGroup)
        cf_group_id = cfmg.cf_id()
        self._cf_id2node[cf_group_id] = cfmg

    def register_structure_group(self, cfsg):
        assert isinstance(cfsg, CfStructureGroup)
        cf_group_id = cfsg.cf_id()
        self._cf_id2node[cf_group_id] = cfsg

    def create_associated_siblings(self, cf_group):
        """Create sibling nodes stemming from a given node.

        NB! This creates cf_structure_groups only.
        """

        for s_name, s_id in cf_group.cf_yield_siblings():
            if self.get_cf_group(s_id):
                continue

            parent = self.get_cf_group(cf_group.cf_parent_id())
            assert parent is not None
            nn = CfStructureGroup(s_name, s_id, parent)
            self.register_structure_group(nn)
            parent.add_child(nn)
            logger.debug("Created sibling %s from %s under parent %s",
                         nn, cf_group, parent)

    def create_associated_structures(self, cf_group, multisemester_map):
        """Given a cf_member/structure_group, create *ALL* the necessary
        associated groups upwards in the structure tree.

        cf_group may be either a cf_structure_group or a CfMemberGroup.

        For cf_structure_group we figure out which group is the parent. If it
        does not exist, it's created (recursively).

        For CfMemberGroup we figure out which structure group it corresponds
        to. If it does not exist, it's created (recursively).

        @return:
          This returns a group that cf_group should be associated
          with. I.e. cf_group's 'closest' node in the structure hierarchy
        """

        if cf_group.cf_id() in multisemester_map:
            structure_id = multisemester_map[cf_group.cf_id()]
            logger.debug("Selecting a remapped parent-id: %s -> %s",
                         cf_group.cf_id(), structure_id)
        else:
            structure_id = cf_group.cf_parent_id()

        if structure_id is None:
            logger.debug("No structure created for cf_group=%s", cf_group)
            return None
        if self.get_cf_group(structure_id):
            self.get_cf_group(structure_id).add_child(cf_group)
            self.create_associated_siblings(cf_group)
            return self.get_cf_group(structure_id)

        # No parent -> create new one
        # Regardless of cf_group's type, we create cf_structure_groups only.
        logger.debug("Creating new node id=%s (parent for %s)",
                     structure_id, cf_group.cf_id())
        new_node = CfStructureGroup(cf_group.cf_parent_title(),
                                    structure_id,
                                    # None, since we don't know what the
                                    # parent is at this point.
                                    None)
        self.register_structure_group(new_node)
        new_node.add_child(cf_group)
        self.create_associated_siblings(cf_group)

        # This will eventually stop at a node that already exist, since we
        # have several static nodes in the tree.
        grandparent_node = self.create_associated_structures(new_node,
                                                             multisemester_map)
        # This will fix new_node's parent link as well.
        grandparent_node.add_child(new_node)
        return new_node

    def iterate_groups(self, group_type=None):
        """Create an iterator for the specific group type in the CF-tree.
        """

        for seq in (iter(self._cf_id2node.values()),
                    (self._person_group_holder,)):
            for group in seq:
                if (group_type is None or
                        isinstance(group, group_type)):
                    yield group

    def iterate_groups_topologically(self, group_type=None):
        """Create an iterator for the specific group type(s) that outputs
        groups in topological order.

        Fronter requires parent groups to be output before children, in order
        for their import routines to function properly.
        """

        if not self._root:
            return

        work_queue = deque((self._root, self._person_group_holder))
        while work_queue:
            current = work_queue.popleft()

            if group_type is None or isinstance(current, group_type):
                yield current

            # Enqueue all the children (CfMemberGroup does not have
            # structural children, which are of interest here)
            if not isinstance(current, CfStructureGroup):
                continue

            for child_group in current.iterate_children(group_type):
                work_queue.append(child_group)

    def get_root(self):
        return self._root


class CfGroupInterface(object):
    """An interface capturing the common functionality of person- and structure
    groups.
    """

    _acronym2avdeling = None

    def __init__(self):
        self._parent = None

    @staticmethod
    def load_acronyms(db):
        result = dict()
        ou = Factory.get("OU")(db)
        const = Factory.get("Constants")()
        for row in ou.search_name_with_language(
                entity_type=const.entity_ou,
                name_variant=const.ou_name_acronym,
                name_language=const.language_nb):
            ou.clear()
            ou.find(row["entity_id"])
            key = "%02d%02d%02d" % (ou.fakultet, ou.institutt, ou.avdeling)
            result[key] = row["name"]
        CfGroupInterface._acronym2avdeling = result

    def __eq__(self, other):
        return self.cf_id() == other.cf_id()

    def __hash__(self):
        return hash(self.cf_id())

    def cf_group_type(self):
        raise NotImplementedError("N/A")

    def cf_id(self):
        raise NotImplementedError("N/A")

    def cf_title(self):
        raise NotImplementedError("N/A")

    def cf_parent_id(self):
        raise NotImplementedError("N/A")

    def cf_typevalue(self):
        raise NotImplementedError("N/A")

    def cf_template(self):
        raise NotImplementedError("N/A")

    @staticmethod
    def kull_room_title(stprog, semester, year):
        return "Rom for kull %s %s %s" % (stprog, semester, year)

    def cf_parent_title(self):
        """Figure out the title of the group where self is a member"""
        # If the parent link already exists, we are done
        if self._parent:
            return self._parent.cf_title()

        # If not, let's guess
        parent_id = self.cf_parent_id()
        parent_components = parent_id.split(":")

        if "klasse" in parent_components:
            return "Rom for kull %s %s %s, klasse %s" % (
                parent_components[-6],
                parent_components[-3],
                parent_components[-4],
                parent_components[-1])

        if "kull" in parent_components:
            # fellesrom is for student-kull group's parent only ...
            if self.cf_group_type() == "student-kull":
                return self.kull_room_title(parent_components[-4],
                                            parent_components[-1],
                                            parent_components[-2])

            # 2 possibilities here -- self is either a ROOM or a group with a
            # kull role holder. In all cases the parent is the same - kull
            # corridor. In either case the parent's name is deduced similarily.
            #
            idx = parent_components.index("kull")
            return "Kull %s %s %s" % (
                parent_components[idx-1],  # stprog
                parent_components[idx+2],  # terminkode
                parent_components[idx+1])  # arstall

        elif "studieprogram" in parent_components:
            idx = parent_components.index("studieprogram")
            return "Studieprogram %s" % parent_components[idx+1].upper()
        elif ("undenh" in parent_components or
              "undakt" in parent_components):
            # group's description (cf_title()) has the right semester number
            # even for multisemester undenh/undakt, this structure will have
            # the right title.
            # FIXME: It is somewhat ugly to rely on a certain structure in
            # group names
            title_components = self.cf_title().split(" ")
            return "Rom for " + " ".join(title_components[2:])
        elif "emner" in parent_components:
            idx = parent_components.index("emner")
            return "Emnerom %s %s" % (parent_components[idx+2],
                                      parent_components[idx+1])
        # avdeling
        elif len(parent_components) == 5 and parent_components[-1].isdigit():
            return "%s" % self._acronym2avdeling[parent_components[-1]]
        elif "automatisk" in parent_components:
            return "Automatisk"
        # for the sake of completeness
        elif "manuell" in parent_components:
            return "Manuell"
        elif "persongruppene" in parent_components:
            return "Samlenode for persongruppene"
        elif parent_id == "root":
            return "Oslofjordalliansen"

        assert False, "This cannot happen: parent_id=%s" % parent_id

    def cf_yield_siblings(self):
        """Return sibling node information to create alongside self.

        This may come in handy when a creation of one node (be it
        CfMemberGroup or cf_structure_group) necessarily entails creating
        additional nodes at the same level.

        By default, no action is performed. This method returns a generator.
        """
        return ((cf_name, cf_id) for (cf_name, cf_id) in ())


@six.python_2_unicode_compatible
class CfStructureGroup(CfGroupInterface):
    """A group representing a structure (a room or a corridor) in CF.

    This class deals with intergroup relations in CF (permissions,
    parent-child relations, etc.). Some cf_structure_groups would have
    CfMemberGroup(s) associated with them (typically student / FS role
    holder groups). That association is used to grant access permissions in
    CF.
    """

    valid_types = ("STRUCTURE", "ROOM")

    def __init__(self, description, cf_id, parent):
        super(CfStructureGroup, self).__init__()
        self._cf_id = cf_id
        self._title = description
        self._parent = parent
        if self._parent:
            self._parent.add_child(self)
        self._structure_children = dict()
        self._permissions = dict()
        self._group_type = self._calculate_group_type()

    def cf_typevalue(self):
        """Return a suitable text value for <typevalue> XML element.

        The meaning of the code values is:

          0 - node
          1 - corridor
          2 - group
          4 - room.
        """

        # FIXME: this is so horribly hackish. There should be a general way of
        # calculating the <typevalue>.
        if self.cf_id() in ("root",
                            "STRUCTURE:hiof.no",
                            "STRUCTURE:hiof.no:automatisk",
                            "STRUCTURE:hiof.no:manuell",
                            "STRUCTURE:hiof.no:persongruppene"):
            return "0"

        # avdeling -> node as per specification
        components = self.cf_id().split(":")
        if len(components) == 5 and components[-1].isdigit():
            return "0"

        # all other STRUCTURE entities are corridors
        if self.cf_group_type() == "STRUCTURE":
            return "1"

        if self.cf_group_type() == "ROOM":
            return "4"

        assert False, "This cannot happen"

    def cf_is_kull_fellesrom(self):
        """Is self fellesrom for a kull?"""

        components = self.cf_id().split(":")
        return (self.cf_group_type() == "ROOM" and
                "kull" in components and
                "klasse" not in components)

    def cf_is_kull_corridor(self):
        """Is self a kull corridor?"""

        components = self.cf_id().split(":")
        return (self.cf_group_type() == "STRUCTURE" and
                "kull" in components)

    def fixup_sibling_permissions(self):
        """Propagate permissions from kullklasse roles to fellesrom for kull.

        Those holdning role permissions on kullklasse room have the same
        permission # set on kull room (fellesrommet for kullet)
        """

        if not self.cf_is_kull_corridor():
            return

        # Does self have fellesrom at all? (it ought to, but let's pretend we
        # need to check this)
        holders = set()
        fellesrom = None
        for child in self.iterate_children(CfStructureGroup):

            for permission in child.iterate_permissions():
                if not permission.holder().cf_is_student_group():
                    holders.add(permission.holder())

            if child.cf_is_kull_fellesrom():
                fellesrom = child

        # if we have fellesrom, every group in 'holders' gets a permission on
        # fellesrom.
        if fellesrom is None:
            return

        # let's go
        for holder in holders:
            logger.debug("%s receives additional permissions from sibling %s",
                         fellesrom, holder)
            fellesrom.register_permissions(holder)

    def cf_template(self):
        assert self.cf_group_type() in self.valid_types
        if self.cf_group_type() == "ROOM":
            return "Mal-rom OA 2"

    def cf_id(self):
        return self._cf_id

    def cf_title(self):
        return self._title

    def cf_group_type(self):
        return self._group_type

    def cf_parent_id(self):
        """Calculate which *structure* group is the parent of this group.

        If the _parent link has already been established, there is nothing to
        do. However, until the _parent link is set, we don't have the actual
        parent node and have to calculate the id itself.

        The idea is to figure out which parent structure group a given
        structure group should be associated with. This happens during the
        creation of the cf structure tree.
        """

        # If the parent link already exists, we are done.
        if self._parent:
            return self._parent.cf_id()

        # Now, which structure node is this?
        components = self.cf_id().split(":")
        if self.cf_group_type() == "ROOM":
            # kullklasse
            if "klasse" in components:
                result = ["STRUCTURE", ] + components[1:-2]
            # kull, fellesrom
            elif "kull" in components:
                result = ["STRUCTURE", ] + components[1:]
            # The guesswork below is potentially incorrect (i.e. it will be
            # incorrect for multisemester undenh/undakt. However, the
            # proper remapping happens elsewhere, and this just captures the
            # general case).
            elif "undenh" in components:
                result = ["STRUCTURE", ] + components[1:-4]
            elif "undakt" in components:
                result = ["STRUCTURE", ] + components[1:-5]
            else:
                assert False, "This cannot happen: self.id=%s" % self.cf_id()
            return ":".join(result)
        else:
            # kull -> stprog
            if "kull" in components:
                result = components[:-3]
            # stprog -> avdeling
            elif "studieprogram" in components:
                result = components[:-2]
            # emnerom -> avdeling
            elif "emner" in components:
                result = components[:-3]
            # avdeling -> automatisk
            elif len(components) == 5 and components[-1].isdigit():
                return "STRUCTURE:hiof.no:automatisk"
            # root is special
            elif self.cf_id() == "root":
                return self.cf_id()
            else:
                assert False, "This cannot happen: self.id=%s" % self.cf_id()
            return ":".join(result)

    def _calculate_group_type(self):
        """Figure out what kind of structure group this is -- STRUCTURE
        (corridor) or ROOM"""

        # root is special. UNFORTUNATELY
        if self.cf_id() == "root":
            return "STRUCTURE"

        components = self.cf_id().split(":")
        assert components[0] in self.valid_types
        return components[0]

    def add_child(self, child):
        self._structure_children[child.cf_id()] = child
        # this will allow us to create parentless nodes, and have them fixed
        # up later on. _parent slot is initialised to None.
        if child._parent != self:
            child._parent = self

    def iterate_children(self, child_type=None):
        for child in iter(self._structure_children.values()):
            if child_type is None or isinstance(child, child_type):
                yield child

    def iterate_permissions(self):
        return iter(self._permissions.values())

    def register_permissions(self, cf_group):
        assert isinstance(cf_group, CfMemberGroup)
        permission = cf_group.get_cf_permission(self)
        if permission is not None:
            self._permissions[cf_group.cf_id()] = permission

        logger.debug("Registered permission %s", permission)

    def __str__(self):
        return ("CFSG id=%s (parent=%s), %d structure members, "
                "%d perm groups" % (
                    self.cf_id(),
                    self._parent and self._parent.cf_id() or "No parent",
                    len(self._structure_children),
                    len(self._permissions)))


@six.python_2_unicode_compatible
class CfMemberGroup(CfGroupInterface):
    """A group holding members of a Cerebrum group for CF.

    All cf_member_groups are 'associated' with a cf_structure_group and
    cf_member_groups are meant to capture user members, whereas
    cf_structure_group captures the overall structure group.

    This class deals with member management and storing member attributes to
    export to CF (unames, e-mails, etc)
    """
    # FS role groups
    valid_types = ("stprog", "kull", "kullklasse", "undenh", "undakt",
                   "avdeling",
                   # FS student groups
                   "student-undenh", "student-undakt",
                   "student-kull", "student-kullklasse",)

    def __init__(self, group):
        super(CfMemberGroup, self).__init__()
        self._cf_id = group.group_name
        self._title = group.description
        self._account_ids = [x["member_id"]
                             for x in group.search_members(
                                 group_id=group.entity_id)]
        self._group_type = self._calculate_group_type()
        self._parent = None
        assert self._group_type in self.valid_types, \
            "Cannot deduce type for group id=%s/name=%s: type=%s" % (
                group.entity_id,
                group.group_name,
                self._group_type)

    def cf_typevalue(self):
        """Return a suitable text value for <typevalue> XML element.

        The meaning of the code values is:

          0 - node
          1 - corridor
          2 - group
          4 - room.
        """

        # CfMemberGroup objects represent 'group' typevalues. Always.
        return "2"

    def cf_id(self):
        return self._cf_id

    def cf_title(self):
        return self._title

    def cf_group_type(self):
        return self._group_type

    def cf_is_student_group(self):
        return self.cf_group_type() in ("student-undenh",
                                        "student-undakt",
                                        "student-kull",
                                        "student-kullklasse",)

    def cf_parent_id(self):
        """Calculate which *structure* group this member group corresponds to.

        The idea is to figure out which structure group a given member group
        should be associated with. Member groups are 'extracted' directly from
        Cerebrum, whereas structure groups will have to be deduced.
        """

        if self._parent is not None:
            return self._parent.cf_id()

        group_type2cf_structure_fixup = {
            "student-undenh":     ("ROOM", -1),
            "student-undakt":     ("ROOM", -1),
            "student-kull":       ("ROOM", -1),
            "student-kullklasse": ("ROOM", -1),
            "undenh":             ("ROOM", -2),
            "undakt":             ("ROOM", -2),
            "kullklasse":         ("ROOM", -2),
            "kull":               ("STRUCTURE", -2),
            "stprog":             ("STRUCTURE", -2),
            "avdeling":           ("STRUCTURE", -2),
        }

        member_group_type = self.cf_group_type()
        if member_group_type in group_type2cf_structure_fixup:
            prefix, last = group_type2cf_structure_fixup[member_group_type]
            components = self.cf_id().split(":")
            return ":".join([prefix, ] + components[:last])
        else:
            assert False, "This cannot happen: cf_member id=%s/type=%s" % (
                self.cf_id(), member_group_type)

    def cf_yield_siblings(self):
        if self.cf_group_type() != "kull":
            return

        # Holding a role with 'kull' implies that the corresponding
        # ROOM/Felles:...:kull MUST be created.
        components = self.cf_id().split(":")
        k_title = self.kull_room_title(components[5],  # stprog
                                       components[8],  # semester
                                       components[7])  # year
        k_id = ":".join(["ROOM", ] + components[:-2])

        for cf_name, cf_id in ((k_title, k_id),):
            yield cf_name, cf_id

    def _role_code(self):
        """What kind of role code does self correspond to?

        This makes sense for role groups only (i.e. NOT student-groups)
        """

        components = self.cf_id().split(":")
        assert "rolle" in components
        for marker in ("assistent", "hovedlærer", "kursansv", "lærer",
                       "kontakt", "veileder", "admin",):
            if marker in components:
                return marker

        assert False, \
            "Impossible: unknown role code for cd id=%s" % self.cf_id()

    def get_cf_permission(self, structure_group):
        """Calculate permission for self on L{structure_group}.

        The calculations are a bit involved, since the permission in question
        depends on both self AND structure_group.
        """

        all_read = {
            "stprog": CfPermission.ROLE_READ,
            "kull": CfPermission.ROLE_READ,
            "kullklasse": CfPermission.ROLE_READ,
            "undenh": CfPermission.ROLE_READ,
            "undakt": CfPermission.ROLE_READ,
            "avdeling": CfPermission.ROLE_READ,
        }

        all_write = {
            "stprog": CfPermission.ROLE_WRITE,
            "kull": CfPermission.ROLE_WRITE,
            "kullklasse": CfPermission.ROLE_WRITE,
            "undenh": CfPermission.ROLE_WRITE,
            "undakt": CfPermission.ROLE_WRITE,
            "avdeling": CfPermission.ROLE_WRITE,
        }

        all_delete = {
            "stprog": CfPermission.ROLE_DELETE,
            "kull": CfPermission.ROLE_DELETE,
            "kullklasse": CfPermission.ROLE_DELETE,
            "undenh": CfPermission.ROLE_DELETE,
            "undakt": CfPermission.ROLE_DELETE,
            "avdeling": CfPermission.ROLE_DELETE,
        }

        all_change = {
            "stprog": CfPermission.ROLE_CHANGE,
            "kull": CfPermission.ROLE_CHANGE,
            "kullklasse": CfPermission.ROLE_CHANGE,
            "undenh": CfPermission.ROLE_CHANGE,
            "undakt": CfPermission.ROLE_CHANGE,
            "avdeling": CfPermission.ROLE_CHANGE,
        }

        role_code2permission = {
            "assistent":   all_read,
            "hovedlærer":  all_change,
            "kursansv":    all_write,
            "lærer":       all_delete,
            "kontakt":     all_read,
            "veileder":    all_write,
            "admin":       {
                "stprog": CfPermission.ROLE_CHANGE,
                "kull": CfPermission.ROLE_CHANGE,
                "kullklasse": CfPermission.ROLE_CHANGE,
                "undenh": CfPermission.ROLE_WRITE,
                "undakt": CfPermission.ROLE_WRITE,
                "avdeling": CfPermission.ROLE_CHANGE,
            },
        }

        recursive = False
        if self.cf_group_type() in ("stprog", "kull", "avdeling"):
            recursive = True

        if self.cf_group_type() in ("student-undenh", "student-undakt",
                                    "student-kullklasse", "student-kull",):
            access_type = CfPermission.ROLE_WRITE
        elif self.cf_group_type() in ("undenh", "undakt", "kullklasse",
                                      "kull", "stprog", "avdeling",):
            # These are the perms stemming from FS roles. We have to look at
            # the specific role
            role_code = self._role_code()
            access_type = role_code2permission[role_code][self.cf_group_type()]
        else:
            logger.debug("Weird group type for %s", self)
            assert False, "This cannot happen"

        perm_object = CfPermission(access_type, recursive,
                                   holder=self,
                                   target=structure_group)
        return perm_object

    def _calculate_group_type(self):
        """Figure out what kind of group this is."""

        suffix_map = {"undenh": "undenh",
                      "undakt": "undakt",
                      "klasse": "kullklasse",
                      "studieprogram": "stprog",
                      "kull": "kull", }

        components = self.cf_id().split(":")
        if "student" in components:
            # don't reshuffle the list (the tests have to be performed in a
            # specific order)
            for marker in ("undenh", "undakt", "klasse", "kull",):
                if marker in components:
                    return "student-" + suffix_map[marker]
            assert False, "This is impossible - no type for %s" % self.cf_id()
        elif "rolle" in components:
            for marker in ("undakt", "undenh",
                           "klasse", "kull", "studieprogram"):
                if marker in components:
                    return suffix_map[marker]

            if (len(components) == 6 and
                    re.search(r"^\d\d0000$", components[3])):
                return "avdeling"

        assert False, "NOTREACHED"

    def __str__(self):
        return "CFMG type=%s id=%s %d members" % (self.cf_group_type(),
                                                  self.cf_id(),
                                                  len(self._account_ids))

    def iterate_members(self):
        return iter(self._account_ids)


class CfMembers(object):
    """A class to keep track of person information in CF.

    Technically, this class is superfluous. However, we can cache a lot of
    information about people in order to speed up the output. All that caching
    is contained within this class. The only interface available is
    L{member_info}, which looks up all the necessary info by account_id.
    """

    def __init__(self, db):
        self.db = db
        self.const = Factory.get("Constants")(db)

    def account2uname(self):
        """Construct a mapping from account_id to account_name.
        """

        account = Factory.get("Account")(self.db)
        result = dict()
        for row in account.list_names(self.const.account_namespace):
            result[row["entity_id"]] = row["entity_name"] + uname_suffix
        return result

    def email2mail_server(self, email):

        # This can't be the right way...
        try:
            ea = EmailAddress(self.db)
            ea.find_by_address(email)
            et = EmailTarget(self.db)
            et.find(ea.get_target_id())
            es = EmailServer(self.db)
            es.find(et.get_server_id())
            return es.name
        except Errors.NotFoundError:
            return ""

    def person2address(self, person_id):
        person = Factory.get("Person")(self.db)
        person.find(person_id)

        def remap(x):
            if x is None:
                return six.text_type()
            return six.text_type(x).strip()

        for source_system in (self.const.system_sap,
                              self.const.system_fs):
            for addr_type in (self.const.address_post,
                              self.const.address_street):
                addr = person.get_entity_address(source=source_system,
                                                 type=addr_type)
                if len(addr) == 1:
                    addr = addr[0]
                    return {"street": remap(addr["city"]), }
                    # "pobox": remap(addr["p_o_box"]),
                    # FIXME: IMS limits this field to 128 chars. This
                    # should be enforced and split into multiple <=128
                    # char chunks.
                    # hiof requests city part only.
                    # According to Fronter, 'locality' is not
                    # supported yet (2009-08-18), and we are asked to
                    # use "street", although city-part should be in
                    # 'locality' if IMS Ent is followed

    def member_info(self):
        """Slurp in info about all members.

        There is a bit of dict-building in this method. That takes time.

        @rtype: dict (int -> dict (str -> str))
        @return:
          A dictionary from account_ids to dicts with the corresponding
          information. The following keys are available:

            - full        (account owner's name)
            - first       (account owner's first name)
            - family      (account owner's last name)
            - email       (email address associated with account)
            - user        (uname@<suffi>)
            - imap-server (imap server associated for email)
            - address     (a dict representing account owner's address)
            - mobile      (account owner's mobile work number from SAP)
        """

        account = Factory.get("Account")(self.db)
        person = Factory.get("Person")(self.db)
        const = self.const
        result = dict()

        logger.debug("Caching e-mail addresses")
        uname2mail = account.getdict_uname2mailaddr()
        logger.debug("%d uname -> e-mail mappings", len(uname2mail))

        logger.debug("Caching member names")
        person_id2name = person.getdict_persons_names(
            source_system=const.system_cached,
            name_types=[const.name_first, const.name_full, const.name_last])
        logger.debug("%d person_id -> name mappings", len(person_id2name))

        logger.debug("Caching mobile phone numbers")
        person_id2phone = dict((int(x["entity_id"]), x["contact_value"])
                               for x in person.list_contact_info(
                                   contact_type=const.contact_mobile_phone,
                                   entity_type=const.entity_person,
                                   source_system=const.system_sap))

        logger.debug("Caching complete user records")
        candidates = account.search(owner_type=const.entity_person)
        logger.debug("%d candidates to consider", len(candidates))
        for row in candidates:
            person_id = row["owner_id"]
            uname = row["name"]
            account_id = row["account_id"]

            if uname not in uname2mail:
                logger.debug(
                    "Ignoring id=%s/uname=%s (person_id=%s): no e-mail",
                    account_id, uname, person_id)
                continue
            email_address = uname2mail[uname]

            if person_id not in person_id2name:
                logger.debug(
                    "Ignoring id=%s/uname=%s (person_id=%s): no name info",
                    account_id, uname, person_id)
                continue

            first_name = person_id2name[person_id].get(const.name_first, "")
            full_name = person_id2name[person_id].get(const.name_full, "")
            family_name = person_id2name[person_id].get(const.name_last, "")
            result[account_id] = {
                "full": full_name,
                "first": first_name,
                "family": family_name,
                "email": email_address,
                "user": uname + uname_suffix,
                "imap-server": self.email2mail_server(email_address),
                "imap-user": uname,
                "address": self.person2address(person_id),
                "mobile": person_id2phone.get(person_id)
            }

        logger.debug("Collected a total of %d user records", len(result))
        return result


def collect_cf_groups(db):
    """Collect all CF groups from Cerebrum."""

    group = Factory.get("Group")(db)
    const = Factory.get("Constants")()

    result = set(r["entity_id"] for r in
                 group.list_traits(code=const.trait_cf_group))
    logger.debug("Collected %d CF groups from Cerebrum", len(result))
    return result


def locate_db_group(db, group_id):
    """Create a Group proxy for the specified group_id.
    """

    group = Factory.get("Group")(db)
    group.find(group_id)
    return group


def build_cf_tree(db, db_groups, multisemester_map):
    """Construct a complete CF tree with all groups and permissions.

    @param db:
      A database proxy.

    @param db_groups:
      Complete list of cerebrum group_ids which are the basis for CF
      population.
    """

    CfGroupInterface.load_acronyms(db)
    tree = CfTree(db)
    for group_id in db_groups:
        db_group = locate_db_group(db, group_id)
        cf_member = CfMemberGroup(db_group)
        tree.register_member_group(cf_member)
        logger.debug("Created CF group %s", cf_member)

        # Now that we have the group node, we create the corresponding
        # structure nodes (all of them).
        node = tree.create_associated_structures(cf_member, multisemester_map)
        if node:
            logger.debug(
                "Created assoc structures for cf_member id=%s. "
                "Parent node is id=%s", cf_member.cf_id(), node.cf_id())
            node.register_permissions(cf_member)
        else:
            logger.debug("No node created for cf_member id=%s",
                         cf_member.cf_id())

    # fixup additional permissions between the siblings of each node, since
    # the permission assignment up to this point has been top-down.
    for group in tree.iterate_groups(CfStructureGroup):
        group.fixup_sibling_permissions()

    logger.debug("Built a CF tree")
    return tree


def open_xml_stream(filename):
    """Open the xml file for writing.

    @return:
      Return an xmlprinter instance ready for output.
    """

    sink = SimilarSizeWriter(filename, "wb")
    sink.max_pct_change = 50
    printer = xmlprinter.xmlprinter(sink,
                                    indent_level=2,
                                    data_mode=1,
                                    input_encoding="utf-8")

    logger.debug("Opened %s for XML output", filename)
    return printer


def output_fixed_header(printer):
    printer.startElement("properties")
    printer.dataElement("datasource", "cerebrum@hiof.no")
    printer.dataElement("datetime", datetime.date.today().strftime("%Y-%m-%d"))
    printer.endElement("properties")


def output_source_element(printer):
    printer.dataElement("source", "cerebrum@hiof.no")


def output_id(id_data, printer):
    printer.startElement("sourcedid")
    output_source_element(printer)
    printer.dataElement("id", id_data)
    printer.endElement("sourcedid")


def output_person_auth(data, printer):
    # "ldap3:" - ldap authentication (3 is probably the server number)
    # "1" for pwencryptiontype means md5
    # "5"                      means authentication via ldap
    printer.dataElement("userid", data["user"],
                        {"password": "ldap3:", "pwencryptiontype": "5", })


def output_person_names(data, printer):
    printer.startElement("name")
    printer.dataElement("fn", data["full"])
    printer.startElement("n")
    if data.get("first"):
        printer.dataElement("given", data["first"])
    if data.get("family"):
        printer.dataElement("family", data["family"])
    printer.endElement("n")
    printer.endElement("name")


def output_email_info(data, printer):
    for required_key in ("imap-server", "imap-user",):
        if not data.get(required_key):
            return

    printer.startElement("extension")

    # The magic keys/values below have been suggested by Fronter.
    printer.emptyElement("emailsettings",
                         {"description": "HiO e-post",
                          "imap_serverdirectory": "mail/",
                          "imap_sentfolder": "INBOX.Sent",
                          "imap_draftfolder": "INBOX.Drafts",
                          "imap_trashfolder": "INBOX.Trash",
                          # According to Fronter, this value means use the same
                          # password as for logging into fronter.
                          "mail_password": "FRONTERLOGIN",
                          "mail_username": data["imap-user"],
                          "mailtype": "1",
                          "use_ssl": "1",
                          "defaultmailbox": "1",
                          "on_delete_action": "trash",
                          "is_primary": "1",
                          "mailserver": data["imap-server"]})
    printer.endElement("extension")


def output_person_address(data, printer):
    if not data.get("address"):
        return

    address = data["address"]
    # No non-empty address field. That happens sometimes.
    if not [x for x in iter(address.values()) if bool(x)]:
        return

    printer.startElement("adr")
    for key in address:
        value = address[key]
        if value:
            printer.dataElement(key, value)
    printer.endElement("adr")


def output_person_phone(data, printer):
    if not data.get("mobile"):
        return

    # 3 means mobile phone in the IMS specification
    printer.dataElement("tel", data["mobile"], {"teltype": "3"})


def output_person_element(data, printer):
    """Output all relevant data for a <person> element.
    """

    printer.startElement("person", {"recstatus": STATUS_ADD})
    output_id(data["user"], printer)
    output_person_auth(data, printer)
    printer.dataElement("email", data["email"])
    output_person_names(data, printer)
    output_email_info(data, printer)
    output_person_address(data, printer)
    output_person_phone(data, printer)
    printer.endElement("person")


def output_people(db, tree, printer):
    """Output information about all people mentioned in at least one group in
    tree.

    The information has already been prepared by the corresponding nodes. The
    only thing we need is to make sure that the same person is not output
    twice.
    """

    logger.debug("Outputting all people registered in the CF-tree (in-memory)")
    member_info = CfMembers(db).member_info()
    processed = set()
    for group in tree.iterate_groups(CfMemberGroup):
        processed.update(group.iterate_members())

    # We want to output the users sorted by id for the ease of by-human
    # comparison.
    for member_id in sorted(processed):
        xml_data = member_info.get(member_id)
        if xml_data is None:
            logger.warn("No data about account_id=%s", member_id)
            continue

        output_person_element(xml_data, printer)


def output_group_element(cf_group, printer, member_group_owner):
    """Output all info pertaining to the specific cf_group"""

    printer.startElement("group", {"recstatus": STATUS_ADD, })
    output_id(cf_group.cf_id(), printer)

    printer.startElement("grouptype")
    printer.dataElement("scheme", "FronterStructure1.0")
    printer.emptyElement("typevalue", {"level": cf_group.cf_typevalue()})
    printer.endElement("grouptype")
    printer.startElement("description")
    if len(cf_group.cf_title()) > 60:
        # printer.emptyElement("short")
        printer.dataElement("long", cf_group.cf_title())
    else:
        printer.dataElement("short", cf_group.cf_title())
    printer.endElement("description")

    printer.startElement("relationship", {"relation": "1"})
    if isinstance(cf_group, CfMemberGroup):
        output_id(member_group_owner, printer)
    else:
        output_id(cf_group.cf_parent_id(), printer)
    printer.emptyElement("label")
    printer.endElement("relationship")
    printer.endElement("group")


def output_member_groups(db, tree, printer):
    """Output all group information about the structures we are building in
    CF.

    db is passed along for completeness. It's unused here.
    """

    member_owner = tree._person_group_holder.cf_id()
    for cf_group in tree.iterate_groups_topologically():
        output_group_element(cf_group, printer, member_owner)


def output_user_membership(group, members, printer):
    """Output XML subtree for the specific membership."""

    printer.startElement("membership")
    output_id(group.cf_id(), printer)
    for member in members:
        printer.startElement("member")
        output_id(member, printer)
        # 1 = person, 2 = group
        printer.dataElement("idtype", "1")
        printer.startElement("role", {"recstatus": STATUS_ADD,
                                      # FIXME: This should be expressed via
                                      # cf_permission, since a specific user
                                      # within a group may have a different
                                      # permission.
                                      "roletype": CfPermission.ROLE_WRITE})
        # 0 = inactive member, 1 = active member
        printer.dataElement("status", "1")
        # FIXME: What does this junk mean? Alle person members seem to have
        # this memberof extension with type=2. This is a blind copy from
        # UiO/UiA.
        printer.startElement("extension")
        printer.emptyElement("memberof", {"type": "2"})
        printer.endElement("extension")
        printer.endElement("role")
        printer.endElement("member")

    printer.endElement("membership")


def output_user_memberships(db, tree, printer):
    """Output all user membership information."""

    account2uname = CfMembers(db).account2uname()
    for group in tree.iterate_groups(CfMemberGroup):
        members = [account2uname[x] for x in group.iterate_members()]
        if not members:
            continue

        output_user_membership(group, members, printer)


def output_viewcontacts(target, permission_holders, printer):
    """Helper function to output viewContacts permissions"""

    printer.startElement("membership")
    output_id(target.cf_id(), printer)
    for gm in permission_holders:
        printer.startElement("member")
        output_id(gm.cf_id(), printer)
        # 1 = person, 2 = group
        printer.dataElement("idtype", "2")
        printer.startElement("role", {"recstatus": STATUS_ADD})
        # 0 = inactive member, 1 = active member
        printer.dataElement("status", "1")
        printer.startElement("extension")
        printer.emptyElement("groupaccess", {"roomAccess": "0",
                                             "contactAccess": "100", })
        printer.endElement("extension")
        printer.endElement("role")
        printer.endElement("member")
    printer.endElement("membership")


def process_viewcontacts_permissions(cf_group, local_permissions,
                                     inherited_permissions, printer):
    """Generate XML for represeting viewContacts permissions related to
    cf_group.

    This is where it gets hairy.
    """

    assert isinstance(cf_group, CfStructureGroup)
    # This methods is called with cf_group == cf_structure_group. Always
    #
    # So, for each such cf_structure_group we need to locate the corresponding
    # cf_member_groups. Some of them are direct children of cf_group. Other
    # are permission holders in local_ or inherited_permissions. NB!
    # isinstance(x.holder(), CfMemberGroup) for x in permissions MUST BE
    # True.
    #
    local_member_groups = set(cf_group.iterate_children(CfMemberGroup))
    local_nonstudents = set(x for x in local_member_groups
                            if not x.cf_is_student_group())
    local_permission_holders = set(x.holder() for x in
                                   local_permissions
                                   if isinstance(x.holder(), CfMemberGroup))
    inherited_permission_holders = set(
        x.holder() for x in inherited_permissions if
        isinstance(x.holder(), CfMemberGroup))
    all_at_this_level = set().union(
        local_member_groups).union(
            local_permission_holders).union(
                inherited_permission_holders)
    all_nonstudent = set(x for x in all_at_this_level
                         if not x.cf_is_student_group())

    logger.debug("ViewContacts at level %s: %d local (%d non-student); "
                 "%d local perm holders, %d inherited perm holders "
                 "%d total at this level",
                 cf_group.cf_id(),
                 len(local_member_groups),
                 len(local_nonstudents),
                 len(local_permission_holders),
                 len(inherited_permission_holders),
                 len(all_at_this_level))

    # If there are no /member/ groups at this level, then there are no
    # viewContacts permissions to hand out. This means that our job is done.
    if not local_member_groups:
        return

    student_member_group = [x for x in local_member_groups
                            if x.cf_is_student_group()]
    assert len(student_member_group) <= 1
    if student_member_group:
        student_member_group = student_member_group[0]
    else:
        student_member_group = None

    # Case 1: *Everybody* has viewContacts on the student group
    if student_member_group:
        output_viewcontacts(student_member_group, all_at_this_level, printer)
        logger.debug(
            "%s is a student group and %s groups have viewContacts on it",
            student_member_group.cf_id(),
            len(all_at_this_level))

    # Case 2: Every nonstudent group at this level has viewContacts on every
    # local nonstudent group
    for g in local_nonstudents:
        output_viewcontacts(g, all_nonstudent, printer)
        logger.debug("%s is local non-student group and %s groups have "
                     "viewContact on it", g.cf_id(), len(all_nonstudent))

    # Case 3: Finally, every local nonstudent group has viewContacts on
    # inherited permission holders. (i.e. local "LÆRER" will have viewContacts
    # on inherited "ADMIN")
    for g in inherited_permission_holders:
        output_viewcontacts(g, local_nonstudents, printer)
        logger.debug("%s is an inherited permission group and %s local groups"
                     "have viewContact on it",
                     g.cf_id(), len(local_nonstudents))


def output_node_permissions(cf_group, local_permissions,
                            inherited_permissions, printer):
    """Generate XML for representing permissions on cf_group.

    permissions is a sequence of cf_permission instances that list permissions
    (direct or indirect) on cf_group. I.e. there may be entries in permissions
    that have target != cf_group.
    """

    permissions = local_permissions + inherited_permissions

    # No permissions -> nothing to do
    if len(permissions) == 0:
        logger.debug("No permissions output for group id=%s",
                     cf_group.cf_id())
        return

    logger.debug("cf_group id=%s has %d local and %d inherited permissions",
                 cf_group.cf_id(), len(local_permissions),
                 len(inherited_permissions))

    printer.startElement("membership")
    output_id(cf_group.cf_id(), printer)
    for permission in permissions:
        printer.startElement("member")
        output_id(permission.holder().cf_id(), printer)
        # 1 = person, 2 = group
        printer.dataElement("idtype", "2")
        printer.startElement("role", {"recstatus": STATUS_ADD,
                                      "roletype": permission.access_type(), })
        # FIXME: what about <extension><memberof type="??"></extension> ?
        # 0 = inactive, 1 = active member
        printer.dataElement("status", "1")
        printer.endElement("role")
        printer.endElement("member")

    printer.endElement("membership")


def process_node_permissions(node, inherited_permissions, printer):
    """Output permissions for the CF subtree with root at node.

    Permissions are generated in depth-first order down the tree.

    @type node: cf_structure_group instance
    @param node:
      Subtree root for which we generate permission data. I.e. other
      structures have permissions on L{node}.

    @type inherited_permissions: sequence of cf_permission instances.
    @param inherited_permissions:
      Sequence of permissions inherited by this node from its parents. Some
      groups result in recursive permissions. E.g. an 'admin' role given for a
      'stprog' is *inherited* for all structures associated with that 'stprog'
      (kull and kullklasse). Should node have its own recursive permissions,
      they are added to inherited_permissions.
    """

    #
    # There is a bit of tuple copying here; hopefully this won't be a
    # performance issue.
    #
    children = node.iterate_children(CfStructureGroup)
    local_permissions = tuple(node.iterate_permissions())
    output_node_permissions(node, local_permissions, inherited_permissions,
                            printer)
    process_viewcontacts_permissions(node, local_permissions,
                                     inherited_permissions, printer)
    node_recursive_permissions = tuple(x for x in local_permissions
                                       if x.is_recursive())

    children_permissions = inherited_permissions + node_recursive_permissions
    for child in children:
        process_node_permissions(child, children_permissions, printer)


def output_permissions(tree, printer):
    """Output all permissions.

    Permissions are expressed in IMS enterprise through memberships, much like
    output_membership. However, in this case groups are members of other
    groups (groups-with-user-members are members of STRUCTURE/ROOM groups).
    """

    root = tree.get_root()
    process_node_permissions(root, tuple(), printer)


def generate_xml_file(filename, db, tree):
    """'Flatten' cf_tree to L{filename}.

    'Flattening' is accomplished in several steps:

      * output people
      * output all groups
      * output all memberships
      * output all permissions
    """

    printer = open_xml_stream(filename)
    printer.startDocument("utf-8")
    printer.startElement("enterprise")
    output_fixed_header(printer)
    output_people(db, tree, printer)
    output_member_groups(db, tree, printer)
    output_user_memberships(db, tree, printer)
    output_permissions(tree, printer)
    printer.endElement("enterprise")
    printer.endDocument()
    printer.fp.close()


def build_multisemester_mapping(undenh_file, undakt_file):
    """Build a dict to remap multisemester (flersemester) entities.

    This function helps to go from a group_name in Cerebrum for
    undenh/undakt-related groups to the structure id of the node in the
    Fronter tree. I.e. we want to assist remapping

    hiof.no:fs:224:400000:emner:2008:vår:undakt:HSS40505:1:1:0

    to

    STRUCTURE:hiof.no:fs:224:400000:emner:2009:vår

    ... if the first one is the start semester for an undakt in its 3rd active
    semester.

    @rtype: dict of str to str
    @return:
      A mapping built for all multisemester entries in the files. Since both
      undenh and undakt have the same structure parent, the mappings are built
      like this:

        'ROOM:hiof.no:fs:224:400000:emner:2008:vår:undakt:HSS40505:1:1:0' ->
        'STRUCTURE:hiof.no:fs:224:400000:emner:2009:vår'

      ... where 2008/vår-components are 'counted back' (see
      populate_fronter_groups._count_back_semester) from the data in
      undenh/undakt file.
    """

    prefix = "hiof.no:%s:" % (cereconf.DEFAULT_INSTITUSJONSNR,)
    value_template = "STRUCTURE:" + prefix + "%02d0000:emner:%s:%s"
    key_template = "ROOM:" + prefix + "%02d0000:emner:%s:%s:%s:%s:%s:%s"

    result = dict()
    for (source,
         entry_kind) in ((EduDataGetter(undenh_file, logger).iter_undenh,
                          "undenh",),
                         (EduDataGetter(undakt_file, logger).iter_undakt,
                          "undakt",)):
        logger.debug("Mapping multisemester %s", entry_kind)
        for entry in source():
            attrs = lower(entry)
            if "terminnr" not in attrs:
                continue

            if not timeslot_is_valid(attrs):
                logger.debug("Ignoring '%s' - data too old/in the future: "
                             "attrs=%s", entry_kind, attrs)
                continue

            # Technically, this is cheating -- faknr_kontroll does not have to
            # match whetever faculty info is in the emne-info.xml
            structure = value_template % (int(attrs["faknr_kontroll"]),
                                          attrs["arstall"],
                                          attrs["terminkode"])
            original = (attrs["arstall"], attrs["terminnr"])
            attrs = count_back_semesters(attrs)
            # remapped = (attrs["arstall"], attrs["terminnr"])
            key = key_template % (int(attrs["faknr_kontroll"]),
                                  attrs["arstall"],
                                  attrs["terminkode"],
                                  entry_kind,
                                  attrs["emnekode"],
                                  attrs["versjonskode"],
                                  attrs["terminnr"])
            if entry_kind == "undakt":
                key = key + ":" + attrs["aktivitetkode"]

            # Key may already be in result! This happens when terminnr=1 and
            # terminnr=2 for the same undenh are in the file. The resulting
            # IDs are the same, since we count back semesters, but the
            # structure to which key is to be associated is NOT. Whichever is
            # earliest must be used.
            if key in result:
                previous_year, previous_sem = result[key].split(":")[-2:]
                if ((int(previous_year) > int(original[0])) or
                    (int(previous_year) == int(original[0]) and
                     previous_sem == "høst")):
                    result[key] = structure
            else:
                result[key] = structure

            logger.debug("Connecting %s to %s", key, result[key])
    return result


def main(inargs=None):
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-x', '--xml-file', dest='xml_file',
                        help='XML-file to be generated',
                        required=True)
    parser.add_argument('-e', '--undenh-file', dest='undenh_file',
                        help='Department XML-export from FS',
                        required=True)
    parser.add_argument('-a', '--undakt-file', dest='undakt_file',
                        help='Activity XML-export from FS',
                        required=True)
    parser.add_argument('-u', '--uname-suffix', dest='uname_suffix',
                        help='Username suffix to be added (default: None)',
                        default='')

    Cerebrum.logutils.options.install_subparser(parser)
    args = parser.parse_args(inargs)
    Cerebrum.logutils.autoconf('cronjob', args)

    global uname_suffix
    uname_suffix = args.uname_suffix

    db = Factory.get("Database")()
    groups = collect_cf_groups(db)
    multisemester_map = build_multisemester_mapping(args.undenh_file,
                                                    args.undakt_file)
    tree = build_cf_tree(db, groups, multisemester_map)
    generate_xml_file(args.xml_file, db, tree)


if __name__ == "__main__":
    main()
